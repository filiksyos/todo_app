module;

import lib.ft4.auth;
import lib.ft4.accounts.strategies.open;
import lib.ft4.core.accounts.{ account, Account, create_account_with_auth, single_sig_auth_descriptor };
import lib.ft4.external.assets.{ get_asset_balances };
import lib.ft4.assets.{ asset, Unsafe, balance };

@extend(auth.auth_handler)
function () = auth.add_auth_handler(
    flags = ["T"]
);

operation register_and_mint_asset(
    asset_name: text,
    symbol: text,
    decimals: integer,
    amount: big_integer,
    icon_url: text
) {
    val owner_account = auth.authenticate();
    require(get_asset_balances(owner_account.id, 10, null).data.empty(), "One asset allowed");
    functions.register_and_mint_asset(owner_account, asset_name, symbol, decimals, amount, icon_url);
}

namespace functions {
    function register_and_mint_asset(
        owner_account: account,
        asset_name: name,
        symbol: text,
        decimals: integer,
        amount: big_integer,
        icon_url: text
    ) {
        // Derive id of the asset
        val asset_id = (asset_name, chain_context.blockchain_rid).hash();

        // check if the asset already exists
        val asset = asset @ ? { .id == asset_id };
        if (not empty(asset)) return;

        val asset_created = Unsafe.register_asset(asset_name, symbol, decimals, chain_context.blockchain_rid, icon_url);
        Unsafe.mint(owner_account, asset_created, amount);
    }
}

// Entity to track staked assets for each account
entity stake {
    key account: account, asset: asset;
    mutable amount: big_integer;
    mutable staked_at: integer = op_context.last_block_time;
}

// Entity to track unstaking requests
entity unstake_request {
    key account: account, asset: asset;
    mutable amount: big_integer;
    mutable requested_at: integer = op_context.last_block_time;
}

// Operation to initiate unstaking of tokens
operation unstake_asset(asset_id: byte_array, amount: big_integer) {
    val owner_account = auth.authenticate();
    val asset = asset @ { .id == asset_id };
    
    require(amount > 0, "Amount must be positive");
    
    val user_stake = stake @ { owner_account, asset };
    require(user_stake.amount >= amount, "Insufficient staked balance");
    
    user_stake.amount -= amount;
    
    val balance = balance @ { owner_account, asset };
    balance.amount += amount;
}

query get_unstake_info(account_id: byte_array, asset_id: byte_array): (amount: big_integer, requested_at: integer) {
    val acc = account @ { .id == account_id };
    val ast = asset @ { .id == asset_id };
    val request = unstake_request @? { acc, ast };
    return (
        amount = if (empty(request)) 0L else request.amount,
        requested_at = if (empty(request)) 0 else request.requested_at
    );
}

operation stake_asset(asset_id: byte_array, amount: big_integer) {
    val owner_account = auth.authenticate();
    val asset = asset @ { .id == asset_id };
    
    require(amount > 0, "Amount must be positive");
    
    val balance = balance @ { owner_account, asset };
    require(balance.amount >= amount, "Insufficient balance");
    
    balance.amount -= amount;
    
    val existing_stake = stake @? { owner_account, asset };
    if (empty(existing_stake)) {
        create stake(owner_account, asset, amount);
    } else {
        existing_stake.amount += amount;
        existing_stake.staked_at = op_context.last_block_time;
    }
}

query get_stake_info(account_id: byte_array, asset_id: byte_array): (amount: big_integer, staked_at: integer) {
    val acc = account @ { .id == account_id };
    val ast = asset @ { .id == asset_id };
    val stake = stake @? { acc, ast };
    return (
        amount = if (empty(stake)) 0L else stake.amount,
        staked_at = if (empty(stake)) 0 else stake.staked_at
    );
}

query get_yield_info(account_id: byte_array, asset_id: byte_array): (amount: big_integer) {
    val acc = account @ { .id == account_id };
    val ast = asset @ { .id == asset_id };
    val stake = stake @? { acc, ast };
    
    return (
        amount = if (empty(stake)) 0L else (stake.amount * 10L) / 100L
    );
}

operation claim_yield(asset_id: byte_array) {
    val owner_account = auth.authenticate();
    val asset = asset @ { .id == asset_id };
    
    val user_stake = stake @ { owner_account, asset };
    require(user_stake.amount > 0, "No active stake found");
    
    val yield_amount = (user_stake.amount * 10L) / 100L;
    require(yield_amount > 0, "No yield to claim");
    
    val balance = balance @ { owner_account, asset };
    balance.amount += yield_amount;
}

// ==========================================
// TODO System Implementation
// ==========================================

entity todo_task {
    key id: text, owner: account;
    mutable title: text;
    mutable description: text = "";
    mutable due_date: text = "";
    mutable completed: boolean = false;
    created_at: text;
}

operation create_todo(
    id: text,
    title: text,
    description: text?,
    due_date: text?,
    created_at: text
) {
    val owner = auth.authenticate();
    create todo_task(
        .id = id,
        .owner = owner,
        .title = title,
        .description = if (empty(description)) "" else description,
        .due_date = if (empty(due_date)) "" else due_date,
        .completed = false,
        .created_at = created_at
    );
}

operation toggle_todo(id: text) {
    val owner = auth.authenticate();
    val task = todo_task @ { owner, .id == id };
    task.completed = not(task.completed);
}

operation delete_todo(id: text) {
    val owner = auth.authenticate();
    delete todo_task @ { owner, .id == id };
}

operation edit_todo(
    id: text,
    title: text,
    description: text?,
    due_date: text?
) {
    val owner = auth.authenticate();
    val task = todo_task @ { owner, .id == id };
    task.title = title;
    task.description = if (empty(description)) "" else description;
    task.due_date = if (empty(due_date)) "" else due_date;
}

query get_todos(account_id: byte_array): list<(text, text, text, text, boolean, text)> {
    val acc = account @ { .id == account_id };
    return todo_task @* { .owner == acc } (
        (.id, .title, .description, .due_date, .completed, .created_at)
    );
}



